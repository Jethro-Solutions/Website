{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Users/emmry/Documents/Jethro%20Solutions/jethro-website-1/src/components/background/abstract-background.tsx"],"sourcesContent":["'use client';\r\n\r\nimport { useRef, useMemo } from 'react';\r\nimport { Canvas, useFrame } from '@react-three/fiber';\r\nimport { Points, PointMaterial } from '@react-three/drei';\r\nimport * as THREE from 'three';\r\n\r\nfunction ParticleField({ count = 5000, color = '#E8E0D5' }) {\r\n  const points = useRef<THREE.Points>(null);\r\n  \r\n  // Generate random positions for particles\r\n  const particles = useMemo(() => {\r\n    const positions = new Float32Array(count * 3);\r\n    for (let i = 0; i < count; i++) {\r\n      positions[i * 3] = (Math.random() - 0.5) * 10;     // x\r\n      positions[i * 3 + 1] = (Math.random() - 0.5) * 10;  // y\r\n      positions[i * 3 + 2] = (Math.random() - 0.5) * 10;  // z\r\n    }\r\n    return positions;\r\n  }, [count]);\r\n\r\n  // Animate particles\r\n  useFrame((state, delta) => {\r\n    if (points.current) {\r\n      points.current.rotation.x += delta * 0.05;\r\n      points.current.rotation.y += delta * 0.01;\r\n    }\r\n  });\r\n\r\n  return (\r\n    <Points ref={points} positions={particles}>\r\n      <PointMaterial\r\n        transparent\r\n        color={color}\r\n        size={0.02}\r\n        sizeAttenuation={true}\r\n        depthWrite={false}\r\n        opacity={0.4}\r\n      />\r\n    </Points>\r\n  );\r\n}\r\n\r\ninterface AbstractBackgroundProps {\r\n  color?: string;\r\n  particleCount?: number;\r\n  className?: string;\r\n}\r\n\r\nexport default function AbstractBackground({\r\n  color = '#E8E0D5',\r\n  particleCount = 5000,\r\n  className = 'w-full h-[40vh]'\r\n}: AbstractBackgroundProps) {\r\n  return (\r\n    <div className={`${className} bg-soft-black`}>\r\n      <Canvas camera={{ position: [0, 0, 5], fov: 50 }}>\r\n        <ParticleField count={particleCount} color={color} />\r\n      </Canvas>\r\n    </div>\r\n  );\r\n} "],"names":[],"mappings":";;;;AAEA;AACA;AAAA;AACA;AAAA;AAJA;;;;;AAOA,SAAS,cAAc,EAAE,QAAQ,IAAI,EAAE,QAAQ,SAAS,EAAE;IACxD,MAAM,SAAS,CAAA,GAAA,qMAAA,CAAA,SAAM,AAAD,EAAgB;IAEpC,0CAA0C;IAC1C,MAAM,YAAY,CAAA,GAAA,qMAAA,CAAA,UAAO,AAAD,EAAE;QACxB,MAAM,YAAY,IAAI,aAAa,QAAQ;QAC3C,IAAK,IAAI,IAAI,GAAG,IAAI,OAAO,IAAK;YAC9B,SAAS,CAAC,IAAI,EAAE,GAAG,CAAC,KAAK,MAAM,KAAK,GAAG,IAAI,IAAQ,IAAI;YACvD,SAAS,CAAC,IAAI,IAAI,EAAE,GAAG,CAAC,KAAK,MAAM,KAAK,GAAG,IAAI,IAAK,IAAI;YACxD,SAAS,CAAC,IAAI,IAAI,EAAE,GAAG,CAAC,KAAK,MAAM,KAAK,GAAG,IAAI,IAAK,IAAI;QAC1D;QACA,OAAO;IACT,GAAG;QAAC;KAAM;IAEV,oBAAoB;IACpB,CAAA,GAAA,+MAAA,CAAA,WAAQ,AAAD,EAAE,CAAC,OAAO;QACf,IAAI,OAAO,OAAO,EAAE;YAClB,OAAO,OAAO,CAAC,QAAQ,CAAC,CAAC,IAAI,QAAQ;YACrC,OAAO,OAAO,CAAC,QAAQ,CAAC,CAAC,IAAI,QAAQ;QACvC;IACF;IAEA,qBACE,8OAAC,0JAAA,CAAA,SAAM;QAAC,KAAK;QAAQ,WAAW;kBAC9B,cAAA,8OAAC,iKAAA,CAAA,gBAAa;YACZ,WAAW;YACX,OAAO;YACP,MAAM;YACN,iBAAiB;YACjB,YAAY;YACZ,SAAS;;;;;;;;;;;AAIjB;AAQe,SAAS,mBAAmB,EACzC,QAAQ,SAAS,EACjB,gBAAgB,IAAI,EACpB,YAAY,iBAAiB,EACL;IACxB,qBACE,8OAAC;QAAI,WAAW,GAAG,UAAU,cAAc,CAAC;kBAC1C,cAAA,8OAAC,mMAAA,CAAA,SAAM;YAAC,QAAQ;gBAAE,UAAU;oBAAC;oBAAG;oBAAG;iBAAE;gBAAE,KAAK;YAAG;sBAC7C,cAAA,8OAAC;gBAAc,OAAO;gBAAe,OAAO;;;;;;;;;;;;;;;;AAIpD","debugId":null}},
    {"offset": {"line": 100, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Users/emmry/Documents/Jethro%20Solutions/jethro-website-1/src/components/background/geometric-background.tsx"],"sourcesContent":["'use client';\r\n\r\nimport { useRef, useMemo, useEffect } from 'react';\r\nimport { Canvas, useFrame } from '@react-three/fiber';\r\nimport { OrbitControls } from '@react-three/drei';\r\nimport * as THREE from 'three';\r\n\r\n// Geometric shape component that creates abstract shapes\r\nfunction GeometricShapes({ color = '#F5A47C' }) {\r\n  const groupRef = useRef<THREE.Group>(null);\r\n  \r\n  // Create multiple geometric objects\r\n  const geometries = useMemo(() => {\r\n    return Array.from({ length: 20 }, (_, i) => ({\r\n      position: [\r\n        (Math.random() - 0.5) * 8,\r\n        (Math.random() - 0.5) * 8,\r\n        (Math.random() - 0.5) * 5\r\n      ],\r\n      rotation: [Math.random() * Math.PI, Math.random() * Math.PI, 0],\r\n      scale: 0.3 + Math.random() * 0.5,\r\n      type: Math.floor(Math.random() * 3), // 0: Icosahedron, 1: Octahedron, 2: Tetrahedron\r\n    }));\r\n  }, []);\r\n  \r\n  // Animation loop\r\n  useFrame((state, delta) => {\r\n    if (groupRef.current) {\r\n      groupRef.current.rotation.y += delta * 0.1;\r\n      groupRef.current.rotation.x += delta * 0.05;\r\n      \r\n      // Animate individual shapes\r\n      groupRef.current.children.forEach((child, i) => {\r\n        child.rotation.x += delta * (0.2 + i * 0.01);\r\n        child.rotation.y += delta * (0.1 + i * 0.01);\r\n      });\r\n    }\r\n  });\r\n\r\n  return (\r\n    <group ref={groupRef}>\r\n      {geometries.map((geo, i) => {\r\n        // Create a different shape based on the type\r\n        let geometry;\r\n        if (geo.type === 0) {\r\n          geometry = <icosahedronGeometry args={[1, 0]} />;\r\n        } else if (geo.type === 1) {\r\n          geometry = <octahedronGeometry args={[1, 0]} />;\r\n        } else {\r\n          geometry = <tetrahedronGeometry args={[1, 0]} />;\r\n        }\r\n        \r\n        return (\r\n          <mesh \r\n            key={i} \r\n            position={new THREE.Vector3(...geo.position as [number, number, number])}\r\n            rotation={new THREE.Euler(...geo.rotation as [number, number, number])}\r\n            scale={geo.scale}\r\n          >\r\n            {geometry}\r\n            <meshStandardMaterial \r\n              color={color} \r\n              wireframe={true}\r\n              transparent\r\n              opacity={0.7}\r\n              emissive={color}\r\n              emissiveIntensity={0.2}\r\n            />\r\n          </mesh>\r\n        );\r\n      })}\r\n    </group>\r\n  );\r\n}\r\n\r\ninterface GeometricBackgroundProps {\r\n  color?: string;\r\n  className?: string;\r\n}\r\n\r\nexport default function GeometricBackground({\r\n  color = '#F5A47C', // Soft orange by default\r\n  className = 'w-full h-[40vh]'\r\n}: GeometricBackgroundProps) {\r\n  return (\r\n    <div className={`${className} bg-soft-black`}>\r\n      <Canvas dpr={[1, 2]} camera={{ position: [0, 0, 8], fov: 40 }}>\r\n        <ambientLight intensity={0.5} />\r\n        <pointLight position={[10, 10, 10]} intensity={1} />\r\n        <GeometricShapes color={color} />\r\n        <OrbitControls \r\n          enableZoom={false} \r\n          enablePan={false}\r\n          autoRotate\r\n          autoRotateSpeed={0.5}\r\n        />\r\n      </Canvas>\r\n    </div>\r\n  );\r\n} "],"names":[],"mappings":";;;;AAEA;AACA;AAAA;AACA;AACA;AALA;;;;;;AAOA,yDAAyD;AACzD,SAAS,gBAAgB,EAAE,QAAQ,SAAS,EAAE;IAC5C,MAAM,WAAW,CAAA,GAAA,qMAAA,CAAA,SAAM,AAAD,EAAe;IAErC,oCAAoC;IACpC,MAAM,aAAa,CAAA,GAAA,qMAAA,CAAA,UAAO,AAAD,EAAE;QACzB,OAAO,MAAM,IAAI,CAAC;YAAE,QAAQ;QAAG,GAAG,CAAC,GAAG,IAAM,CAAC;gBAC3C,UAAU;oBACR,CAAC,KAAK,MAAM,KAAK,GAAG,IAAI;oBACxB,CAAC,KAAK,MAAM,KAAK,GAAG,IAAI;oBACxB,CAAC,KAAK,MAAM,KAAK,GAAG,IAAI;iBACzB;gBACD,UAAU;oBAAC,KAAK,MAAM,KAAK,KAAK,EAAE;oBAAE,KAAK,MAAM,KAAK,KAAK,EAAE;oBAAE;iBAAE;gBAC/D,OAAO,MAAM,KAAK,MAAM,KAAK;gBAC7B,MAAM,KAAK,KAAK,CAAC,KAAK,MAAM,KAAK;YACnC,CAAC;IACH,GAAG,EAAE;IAEL,iBAAiB;IACjB,CAAA,GAAA,+MAAA,CAAA,WAAQ,AAAD,EAAE,CAAC,OAAO;QACf,IAAI,SAAS,OAAO,EAAE;YACpB,SAAS,OAAO,CAAC,QAAQ,CAAC,CAAC,IAAI,QAAQ;YACvC,SAAS,OAAO,CAAC,QAAQ,CAAC,CAAC,IAAI,QAAQ;YAEvC,4BAA4B;YAC5B,SAAS,OAAO,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,OAAO;gBACxC,MAAM,QAAQ,CAAC,CAAC,IAAI,QAAQ,CAAC,MAAM,IAAI,IAAI;gBAC3C,MAAM,QAAQ,CAAC,CAAC,IAAI,QAAQ,CAAC,MAAM,IAAI,IAAI;YAC7C;QACF;IACF;IAEA,qBACE,8OAAC;QAAM,KAAK;kBACT,WAAW,GAAG,CAAC,CAAC,KAAK;YACpB,6CAA6C;YAC7C,IAAI;YACJ,IAAI,IAAI,IAAI,KAAK,GAAG;gBAClB,yBAAW,8OAAC;oBAAoB,MAAM;wBAAC;wBAAG;qBAAE;;;;;;YAC9C,OAAO,IAAI,IAAI,IAAI,KAAK,GAAG;gBACzB,yBAAW,8OAAC;oBAAmB,MAAM;wBAAC;wBAAG;qBAAE;;;;;;YAC7C,OAAO;gBACL,yBAAW,8OAAC;oBAAoB,MAAM;wBAAC;wBAAG;qBAAE;;;;;;YAC9C;YAEA,qBACE,8OAAC;gBAEC,UAAU,IAAI,+IAAA,CAAA,UAAa,IAAI,IAAI,QAAQ;gBAC3C,UAAU,IAAI,+IAAA,CAAA,QAAW,IAAI,IAAI,QAAQ;gBACzC,OAAO,IAAI,KAAK;;oBAEf;kCACD,8OAAC;wBACC,OAAO;wBACP,WAAW;wBACX,WAAW;wBACX,SAAS;wBACT,UAAU;wBACV,mBAAmB;;;;;;;eAZhB;;;;;QAgBX;;;;;;AAGN;AAOe,SAAS,oBAAoB,EAC1C,QAAQ,SAAS,EACjB,YAAY,iBAAiB,EACJ;IACzB,qBACE,8OAAC;QAAI,WAAW,GAAG,UAAU,cAAc,CAAC;kBAC1C,cAAA,8OAAC,mMAAA,CAAA,SAAM;YAAC,KAAK;gBAAC;gBAAG;aAAE;YAAE,QAAQ;gBAAE,UAAU;oBAAC;oBAAG;oBAAG;iBAAE;gBAAE,KAAK;YAAG;;8BAC1D,8OAAC;oBAAa,WAAW;;;;;;8BACzB,8OAAC;oBAAW,UAAU;wBAAC;wBAAI;wBAAI;qBAAG;oBAAE,WAAW;;;;;;8BAC/C,8OAAC;oBAAgB,OAAO;;;;;;8BACxB,8OAAC,iKAAA,CAAA,gBAAa;oBACZ,YAAY;oBACZ,WAAW;oBACX,UAAU;oBACV,iBAAiB;;;;;;;;;;;;;;;;;AAK3B","debugId":null}},
    {"offset": {"line": 290, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Users/emmry/Documents/Jethro%20Solutions/jethro-website-1/src/components/background/floating-cubes.tsx"],"sourcesContent":["'use client';\r\n\r\nimport { useRef, useMemo } from 'react';\r\nimport { Canvas, useFrame } from '@react-three/fiber';\r\nimport { OrbitControls } from '@react-three/drei';\r\nimport * as THREE from 'three';\r\n\r\nfunction FloatingCubes({ color = '#F5A47C' }) {\r\n  const groupRef = useRef<THREE.Group>(null);\r\n  \r\n  // Create multiple floating cubes\r\n  const cubes = useMemo(() => {\r\n    return Array.from({ length: 30 }, () => ({\r\n      position: [\r\n        (Math.random() - 0.5) * 10,\r\n        (Math.random() - 0.5) * 10,\r\n        (Math.random() - 0.5) * 10\r\n      ],\r\n      rotation: [Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI],\r\n      scale: 0.2 + Math.random() * 0.4,\r\n      speed: 0.2 + Math.random() * 0.5,\r\n      offset: Math.random() * Math.PI * 2,\r\n    }));\r\n  }, []);\r\n  \r\n  // Animation loop\r\n  useFrame((state, delta) => {\r\n    if (groupRef.current) {\r\n      groupRef.current.rotation.y += delta * 0.05;\r\n      \r\n      // Animate individual cubes\r\n      groupRef.current.children.forEach((child, i) => {\r\n        const time = state.clock.elapsedTime;\r\n        const cube = cubes[i];\r\n        // Make cubes float up and down\r\n        child.position.y = cube.position[1] + Math.sin(time * cube.speed + cube.offset) * 0.5;\r\n        // Rotate cubes\r\n        child.rotation.x += delta * cube.speed;\r\n        child.rotation.z += delta * cube.speed * 0.5;\r\n      });\r\n    }\r\n  });\r\n\r\n  return (\r\n    <group ref={groupRef}>\r\n      {cubes.map((cube, i) => (\r\n        <mesh \r\n          key={i} \r\n          position={new THREE.Vector3(...cube.position as [number, number, number])}\r\n          rotation={new THREE.Euler(...cube.rotation as [number, number, number])}\r\n          scale={cube.scale}\r\n        >\r\n          <boxGeometry args={[1, 1, 1]} />\r\n          <meshStandardMaterial \r\n            color={color} \r\n            wireframe={true}\r\n            transparent\r\n            opacity={0.7}\r\n            emissive={color}\r\n            emissiveIntensity={0.3}\r\n          />\r\n        </mesh>\r\n      ))}\r\n    </group>\r\n  );\r\n}\r\n\r\ninterface FloatingCubesBackgroundProps {\r\n  color?: string;\r\n  className?: string;\r\n}\r\n\r\nexport default function FloatingCubesBackground({\r\n  color = '#F5A47C',\r\n  className = 'w-full h-screen'\r\n}: FloatingCubesBackgroundProps) {\r\n  return (\r\n    <div className={`${className} bg-soft-black`}>\r\n      <Canvas dpr={[1, 2]} camera={{ position: [0, 0, 10], fov: 40 }}>\r\n        <ambientLight intensity={0.5} />\r\n        <pointLight position={[10, 10, 10]} intensity={1} />\r\n        <FloatingCubes color={color} />\r\n        <OrbitControls \r\n          enableZoom={false} \r\n          enablePan={false}\r\n          autoRotate\r\n          autoRotateSpeed={0.2}\r\n        />\r\n      </Canvas>\r\n    </div>\r\n  );\r\n} "],"names":[],"mappings":";;;;AAEA;AACA;AAAA;AACA;AACA;AALA;;;;;;AAOA,SAAS,cAAc,EAAE,QAAQ,SAAS,EAAE;IAC1C,MAAM,WAAW,CAAA,GAAA,qMAAA,CAAA,SAAM,AAAD,EAAe;IAErC,iCAAiC;IACjC,MAAM,QAAQ,CAAA,GAAA,qMAAA,CAAA,UAAO,AAAD,EAAE;QACpB,OAAO,MAAM,IAAI,CAAC;YAAE,QAAQ;QAAG,GAAG,IAAM,CAAC;gBACvC,UAAU;oBACR,CAAC,KAAK,MAAM,KAAK,GAAG,IAAI;oBACxB,CAAC,KAAK,MAAM,KAAK,GAAG,IAAI;oBACxB,CAAC,KAAK,MAAM,KAAK,GAAG,IAAI;iBACzB;gBACD,UAAU;oBAAC,KAAK,MAAM,KAAK,KAAK,EAAE;oBAAE,KAAK,MAAM,KAAK,KAAK,EAAE;oBAAE,KAAK,MAAM,KAAK,KAAK,EAAE;iBAAC;gBACrF,OAAO,MAAM,KAAK,MAAM,KAAK;gBAC7B,OAAO,MAAM,KAAK,MAAM,KAAK;gBAC7B,QAAQ,KAAK,MAAM,KAAK,KAAK,EAAE,GAAG;YACpC,CAAC;IACH,GAAG,EAAE;IAEL,iBAAiB;IACjB,CAAA,GAAA,+MAAA,CAAA,WAAQ,AAAD,EAAE,CAAC,OAAO;QACf,IAAI,SAAS,OAAO,EAAE;YACpB,SAAS,OAAO,CAAC,QAAQ,CAAC,CAAC,IAAI,QAAQ;YAEvC,2BAA2B;YAC3B,SAAS,OAAO,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,OAAO;gBACxC,MAAM,OAAO,MAAM,KAAK,CAAC,WAAW;gBACpC,MAAM,OAAO,KAAK,CAAC,EAAE;gBACrB,+BAA+B;gBAC/B,MAAM,QAAQ,CAAC,CAAC,GAAG,KAAK,QAAQ,CAAC,EAAE,GAAG,KAAK,GAAG,CAAC,OAAO,KAAK,KAAK,GAAG,KAAK,MAAM,IAAI;gBAClF,eAAe;gBACf,MAAM,QAAQ,CAAC,CAAC,IAAI,QAAQ,KAAK,KAAK;gBACtC,MAAM,QAAQ,CAAC,CAAC,IAAI,QAAQ,KAAK,KAAK,GAAG;YAC3C;QACF;IACF;IAEA,qBACE,8OAAC;QAAM,KAAK;kBACT,MAAM,GAAG,CAAC,CAAC,MAAM,kBAChB,8OAAC;gBAEC,UAAU,IAAI,+IAAA,CAAA,UAAa,IAAI,KAAK,QAAQ;gBAC5C,UAAU,IAAI,+IAAA,CAAA,QAAW,IAAI,KAAK,QAAQ;gBAC1C,OAAO,KAAK,KAAK;;kCAEjB,8OAAC;wBAAY,MAAM;4BAAC;4BAAG;4BAAG;yBAAE;;;;;;kCAC5B,8OAAC;wBACC,OAAO;wBACP,WAAW;wBACX,WAAW;wBACX,SAAS;wBACT,UAAU;wBACV,mBAAmB;;;;;;;eAZhB;;;;;;;;;;AAkBf;AAOe,SAAS,wBAAwB,EAC9C,QAAQ,SAAS,EACjB,YAAY,iBAAiB,EACA;IAC7B,qBACE,8OAAC;QAAI,WAAW,GAAG,UAAU,cAAc,CAAC;kBAC1C,cAAA,8OAAC,mMAAA,CAAA,SAAM;YAAC,KAAK;gBAAC;gBAAG;aAAE;YAAE,QAAQ;gBAAE,UAAU;oBAAC;oBAAG;oBAAG;iBAAG;gBAAE,KAAK;YAAG;;8BAC3D,8OAAC;oBAAa,WAAW;;;;;;8BACzB,8OAAC;oBAAW,UAAU;wBAAC;wBAAI;wBAAI;qBAAG;oBAAE,WAAW;;;;;;8BAC/C,8OAAC;oBAAc,OAAO;;;;;;8BACtB,8OAAC,iKAAA,CAAA,gBAAa;oBACZ,YAAY;oBACZ,WAAW;oBACX,UAAU;oBACV,iBAAiB;;;;;;;;;;;;;;;;;AAK3B","debugId":null}},
    {"offset": {"line": 456, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Users/emmry/Documents/Jethro%20Solutions/jethro-website-1/src/components/background/wave-background.tsx"],"sourcesContent":["'use client';\r\n\r\nimport { useRef } from 'react';\r\nimport { Canvas, useFrame } from '@react-three/fiber';\r\nimport { OrbitControls } from '@react-three/drei';\r\nimport * as THREE from 'three';\r\n\r\nfunction WaveMesh({ color = '#F5A47C' }) {\r\n  const meshRef = useRef<THREE.Mesh>(null);\r\n  const geometryRef = useRef<THREE.PlaneGeometry>(null);\r\n  \r\n  // Animation loop\r\n  useFrame((state, delta) => {\r\n    if (meshRef.current && geometryRef.current) {\r\n      // Get vertices\r\n      const time = state.clock.elapsedTime;\r\n      const position = geometryRef.current.attributes.position;\r\n      \r\n      // Update each vertex position based on its x,z coordinates\r\n      for (let i = 0; i < position.count; i++) {\r\n        const x = position.getX(i);\r\n        const z = position.getZ(i);\r\n        \r\n        // Create wave pattern\r\n        const amplitude = 0.8;\r\n        const frequency = 0.5;\r\n        const y = amplitude * Math.sin(x * frequency + time) * \r\n                 Math.cos(z * frequency + time * 0.7);\r\n        \r\n        // Update y position\r\n        position.setY(i, y);\r\n      }\r\n      \r\n      position.needsUpdate = true;\r\n      geometryRef.current.computeVertexNormals();\r\n      \r\n      // Slow rotation\r\n      meshRef.current.rotation.y += delta * 0.1;\r\n    }\r\n  });\r\n\r\n  return (\r\n    <mesh ref={meshRef} rotation={[Math.PI / 6, 0, 0]}>\r\n      <planeGeometry ref={geometryRef} args={[10, 10, 50, 50]} />\r\n      <meshStandardMaterial \r\n        color={color}\r\n        wireframe={true}\r\n        side={THREE.DoubleSide}\r\n        transparent\r\n        opacity={0.7}\r\n        emissive={color}\r\n        emissiveIntensity={0.3}\r\n      />\r\n    </mesh>\r\n  );\r\n}\r\n\r\ninterface WaveBackgroundProps {\r\n  color?: string;\r\n  className?: string;\r\n}\r\n\r\nexport default function WaveBackground({\r\n  color = '#F5A47C',\r\n  className = 'w-full h-screen'\r\n}: WaveBackgroundProps) {\r\n  return (\r\n    <div className={`${className} bg-soft-black`}>\r\n      <Canvas dpr={[1, 2]} camera={{ position: [0, 2, 5], fov: 45 }}>\r\n        <ambientLight intensity={0.5} />\r\n        <pointLight position={[10, 10, 10]} intensity={1} />\r\n        <WaveMesh color={color} />\r\n        <OrbitControls \r\n          enableZoom={false}\r\n          enablePan={false}\r\n          enableRotate={true}\r\n          maxPolarAngle={Math.PI / 2}\r\n          minPolarAngle={Math.PI / 6}\r\n        />\r\n      </Canvas>\r\n    </div>\r\n  );\r\n} "],"names":[],"mappings":";;;;AAEA;AACA;AAAA;AACA;AACA;AALA;;;;;;AAOA,SAAS,SAAS,EAAE,QAAQ,SAAS,EAAE;IACrC,MAAM,UAAU,CAAA,GAAA,qMAAA,CAAA,SAAM,AAAD,EAAc;IACnC,MAAM,cAAc,CAAA,GAAA,qMAAA,CAAA,SAAM,AAAD,EAAuB;IAEhD,iBAAiB;IACjB,CAAA,GAAA,+MAAA,CAAA,WAAQ,AAAD,EAAE,CAAC,OAAO;QACf,IAAI,QAAQ,OAAO,IAAI,YAAY,OAAO,EAAE;YAC1C,eAAe;YACf,MAAM,OAAO,MAAM,KAAK,CAAC,WAAW;YACpC,MAAM,WAAW,YAAY,OAAO,CAAC,UAAU,CAAC,QAAQ;YAExD,2DAA2D;YAC3D,IAAK,IAAI,IAAI,GAAG,IAAI,SAAS,KAAK,EAAE,IAAK;gBACvC,MAAM,IAAI,SAAS,IAAI,CAAC;gBACxB,MAAM,IAAI,SAAS,IAAI,CAAC;gBAExB,sBAAsB;gBACtB,MAAM,YAAY;gBAClB,MAAM,YAAY;gBAClB,MAAM,IAAI,YAAY,KAAK,GAAG,CAAC,IAAI,YAAY,QACtC,KAAK,GAAG,CAAC,IAAI,YAAY,OAAO;gBAEzC,oBAAoB;gBACpB,SAAS,IAAI,CAAC,GAAG;YACnB;YAEA,SAAS,WAAW,GAAG;YACvB,YAAY,OAAO,CAAC,oBAAoB;YAExC,gBAAgB;YAChB,QAAQ,OAAO,CAAC,QAAQ,CAAC,CAAC,IAAI,QAAQ;QACxC;IACF;IAEA,qBACE,8OAAC;QAAK,KAAK;QAAS,UAAU;YAAC,KAAK,EAAE,GAAG;YAAG;YAAG;SAAE;;0BAC/C,8OAAC;gBAAc,KAAK;gBAAa,MAAM;oBAAC;oBAAI;oBAAI;oBAAI;iBAAG;;;;;;0BACvD,8OAAC;gBACC,OAAO;gBACP,WAAW;gBACX,MAAM,+IAAA,CAAA,aAAgB;gBACtB,WAAW;gBACX,SAAS;gBACT,UAAU;gBACV,mBAAmB;;;;;;;;;;;;AAI3B;AAOe,SAAS,eAAe,EACrC,QAAQ,SAAS,EACjB,YAAY,iBAAiB,EACT;IACpB,qBACE,8OAAC;QAAI,WAAW,GAAG,UAAU,cAAc,CAAC;kBAC1C,cAAA,8OAAC,mMAAA,CAAA,SAAM;YAAC,KAAK;gBAAC;gBAAG;aAAE;YAAE,QAAQ;gBAAE,UAAU;oBAAC;oBAAG;oBAAG;iBAAE;gBAAE,KAAK;YAAG;;8BAC1D,8OAAC;oBAAa,WAAW;;;;;;8BACzB,8OAAC;oBAAW,UAAU;wBAAC;wBAAI;wBAAI;qBAAG;oBAAE,WAAW;;;;;;8BAC/C,8OAAC;oBAAS,OAAO;;;;;;8BACjB,8OAAC,iKAAA,CAAA,gBAAa;oBACZ,YAAY;oBACZ,WAAW;oBACX,cAAc;oBACd,eAAe,KAAK,EAAE,GAAG;oBACzB,eAAe,KAAK,EAAE,GAAG;;;;;;;;;;;;;;;;;AAKnC","debugId":null}},
    {"offset": {"line": 610, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Users/emmry/Documents/Jethro%20Solutions/jethro-website-1/src/components/background/connected-nodes.tsx"],"sourcesContent":["'use client';\r\n\r\nimport { useRef, useMemo } from 'react';\r\nimport { Canvas, useFrame } from '@react-three/fiber';\r\nimport { OrbitControls, Line } from '@react-three/drei';\r\nimport * as THREE from 'three';\r\n\r\nfunction NodeNetwork({ color = '#F5A47C', nodeCount = 25, maxConnections = 50 }) {\r\n  const nodesRef = useRef<THREE.Group>(null);\r\n  const connectionsRef = useRef<THREE.Group>(null);\r\n  \r\n  // Create nodes\r\n  const nodes = useMemo(() => {\r\n    return Array.from({ length: nodeCount }, () => ({\r\n      position: [\r\n        (Math.random() - 0.5) * 10,\r\n        (Math.random() - 0.5) * 10,\r\n        (Math.random() - 0.5) * 10\r\n      ],\r\n      velocity: [\r\n        (Math.random() - 0.5) * 0.02,\r\n        (Math.random() - 0.5) * 0.02,\r\n        (Math.random() - 0.5) * 0.02\r\n      ],\r\n      connections: [] as number[],\r\n      size: 0.05 + Math.random() * 0.1\r\n    }));\r\n  }, [nodeCount]);\r\n  \r\n  // Create connections between nodes\r\n  const connections = useMemo(() => {\r\n    const lines: { start: number[]; end: number[] }[] = [];\r\n    \r\n    // Find closest nodes and connect them\r\n    for (let i = 0; i < nodes.length; i++) {\r\n      const nodeA = nodes[i];\r\n      const distances: { index: number; distance: number }[] = [];\r\n      \r\n      // Calculate distances to all other nodes\r\n      for (let j = 0; j < nodes.length; j++) {\r\n        if (i !== j) {\r\n          const nodeB = nodes[j];\r\n          const dx = nodeA.position[0] - nodeB.position[0];\r\n          const dy = nodeA.position[1] - nodeB.position[1];\r\n          const dz = nodeA.position[2] - nodeB.position[2];\r\n          const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\r\n          \r\n          distances.push({ index: j, distance });\r\n        }\r\n      }\r\n      \r\n      // Sort by distance and get closest nodes\r\n      distances.sort((a, b) => a.distance - b.distance);\r\n      const connectCount = Math.min(3, distances.length);\r\n      \r\n      // Create connections to closest nodes\r\n      for (let c = 0; c < connectCount; c++) {\r\n        const targetIndex = distances[c].index;\r\n        \r\n        // Check if this connection already exists\r\n        if (!nodeA.connections.includes(targetIndex) && lines.length < maxConnections) {\r\n          lines.push({\r\n            start: [...nodeA.position] as number[],\r\n            end: [...nodes[targetIndex].position] as number[]\r\n          });\r\n          \r\n          nodeA.connections.push(targetIndex);\r\n          nodes[targetIndex].connections.push(i);\r\n        }\r\n      }\r\n    }\r\n    \r\n    return lines;\r\n  }, [nodes, maxConnections]);\r\n  \r\n  // Animation loop\r\n  useFrame((state, delta) => {\r\n    if (nodesRef.current && connectionsRef.current) {\r\n      // Move nodes\r\n      nodesRef.current.children.forEach((node, i) => {\r\n        const nodeData = nodes[i];\r\n        \r\n        // Update position\r\n        for (let axis = 0; axis < 3; axis++) {\r\n          nodeData.position[axis] += nodeData.velocity[axis];\r\n          \r\n          // Bounce off boundaries\r\n          if (Math.abs(nodeData.position[axis]) > 5) {\r\n            nodeData.velocity[axis] *= -1;\r\n          }\r\n        }\r\n        \r\n        // Update mesh position\r\n        node.position.set(\r\n          nodeData.position[0],\r\n          nodeData.position[1],\r\n          nodeData.position[2]\r\n        );\r\n      });\r\n      \r\n      // Update connections\r\n      connectionsRef.current.children.forEach((line, i) => {\r\n        const connection = connections[i];\r\n        const startNode = nodes[nodes.findIndex(n => \r\n          n.position[0] === connection.start[0] && \r\n          n.position[1] === connection.start[1] && \r\n          n.position[2] === connection.start[2]\r\n        )];\r\n        \r\n        const endNode = nodes[nodes.findIndex(n => \r\n          n.position[0] === connection.end[0] && \r\n          n.position[1] === connection.end[1] && \r\n          n.position[2] === connection.end[2]\r\n        )];\r\n        \r\n        if (startNode && endNode) {\r\n          // Update line positions\r\n          const linePoints = [\r\n            new THREE.Vector3(startNode.position[0], startNode.position[1], startNode.position[2]),\r\n            new THREE.Vector3(endNode.position[0], endNode.position[1], endNode.position[2])\r\n          ];\r\n          \r\n          (line as any).geometry.setFromPoints(linePoints);\r\n        }\r\n      });\r\n      \r\n      // Rotate entire network slowly\r\n      nodesRef.current.rotation.y += delta * 0.05;\r\n      connectionsRef.current.rotation.y += delta * 0.05;\r\n    }\r\n  });\r\n\r\n  return (\r\n    <>\r\n      {/* Nodes */}\r\n      <group ref={nodesRef}>\r\n        {nodes.map((node, i) => (\r\n          <mesh \r\n            key={`node-${i}`} \r\n            position={new THREE.Vector3(...node.position as [number, number, number])}\r\n          >\r\n            <sphereGeometry args={[node.size, 8, 8]} />\r\n            <meshStandardMaterial \r\n              color={color}\r\n              emissive={color}\r\n              emissiveIntensity={0.5}\r\n            />\r\n          </mesh>\r\n        ))}\r\n      </group>\r\n      \r\n      {/* Connections */}\r\n      <group ref={connectionsRef}>\r\n        {connections.map((connection, i) => (\r\n          <Line\r\n            key={`connection-${i}`}\r\n            points={[\r\n              new THREE.Vector3(...connection.start as [number, number, number]),\r\n              new THREE.Vector3(...connection.end as [number, number, number])\r\n            ]}\r\n            color={color}\r\n            lineWidth={1}\r\n            transparent\r\n            opacity={0.4}\r\n          />\r\n        ))}\r\n      </group>\r\n    </>\r\n  );\r\n}\r\n\r\ninterface ConnectedNodesProps {\r\n  color?: string;\r\n  className?: string;\r\n}\r\n\r\nexport default function ConnectedNodes({\r\n  color = '#F5A47C',\r\n  className = 'w-full h-screen'\r\n}: ConnectedNodesProps) {\r\n  return (\r\n    <div className={`${className} bg-soft-black`}>\r\n      <Canvas dpr={[1, 2]} camera={{ position: [0, 0, 15], fov: 40 }}>\r\n        <ambientLight intensity={0.5} />\r\n        <pointLight position={[10, 10, 10]} intensity={1} />\r\n        <NodeNetwork color={color} />\r\n        <OrbitControls \r\n          enableZoom={false}\r\n          enablePan={false}\r\n          autoRotate\r\n          autoRotateSpeed={0.3}\r\n        />\r\n      </Canvas>\r\n    </div>\r\n  );\r\n} "],"names":[],"mappings":";;;;AAEA;AACA;AAAA;AACA;AAAA;AACA;AALA;;;;;;AAOA,SAAS,YAAY,EAAE,QAAQ,SAAS,EAAE,YAAY,EAAE,EAAE,iBAAiB,EAAE,EAAE;IAC7E,MAAM,WAAW,CAAA,GAAA,qMAAA,CAAA,SAAM,AAAD,EAAe;IACrC,MAAM,iBAAiB,CAAA,GAAA,qMAAA,CAAA,SAAM,AAAD,EAAe;IAE3C,eAAe;IACf,MAAM,QAAQ,CAAA,GAAA,qMAAA,CAAA,UAAO,AAAD,EAAE;QACpB,OAAO,MAAM,IAAI,CAAC;YAAE,QAAQ;QAAU,GAAG,IAAM,CAAC;gBAC9C,UAAU;oBACR,CAAC,KAAK,MAAM,KAAK,GAAG,IAAI;oBACxB,CAAC,KAAK,MAAM,KAAK,GAAG,IAAI;oBACxB,CAAC,KAAK,MAAM,KAAK,GAAG,IAAI;iBACzB;gBACD,UAAU;oBACR,CAAC,KAAK,MAAM,KAAK,GAAG,IAAI;oBACxB,CAAC,KAAK,MAAM,KAAK,GAAG,IAAI;oBACxB,CAAC,KAAK,MAAM,KAAK,GAAG,IAAI;iBACzB;gBACD,aAAa,EAAE;gBACf,MAAM,OAAO,KAAK,MAAM,KAAK;YAC/B,CAAC;IACH,GAAG;QAAC;KAAU;IAEd,mCAAmC;IACnC,MAAM,cAAc,CAAA,GAAA,qMAAA,CAAA,UAAO,AAAD,EAAE;QAC1B,MAAM,QAA8C,EAAE;QAEtD,sCAAsC;QACtC,IAAK,IAAI,IAAI,GAAG,IAAI,MAAM,MAAM,EAAE,IAAK;YACrC,MAAM,QAAQ,KAAK,CAAC,EAAE;YACtB,MAAM,YAAmD,EAAE;YAE3D,yCAAyC;YACzC,IAAK,IAAI,IAAI,GAAG,IAAI,MAAM,MAAM,EAAE,IAAK;gBACrC,IAAI,MAAM,GAAG;oBACX,MAAM,QAAQ,KAAK,CAAC,EAAE;oBACtB,MAAM,KAAK,MAAM,QAAQ,CAAC,EAAE,GAAG,MAAM,QAAQ,CAAC,EAAE;oBAChD,MAAM,KAAK,MAAM,QAAQ,CAAC,EAAE,GAAG,MAAM,QAAQ,CAAC,EAAE;oBAChD,MAAM,KAAK,MAAM,QAAQ,CAAC,EAAE,GAAG,MAAM,QAAQ,CAAC,EAAE;oBAChD,MAAM,WAAW,KAAK,IAAI,CAAC,KAAK,KAAK,KAAK,KAAK,KAAK;oBAEpD,UAAU,IAAI,CAAC;wBAAE,OAAO;wBAAG;oBAAS;gBACtC;YACF;YAEA,yCAAyC;YACzC,UAAU,IAAI,CAAC,CAAC,GAAG,IAAM,EAAE,QAAQ,GAAG,EAAE,QAAQ;YAChD,MAAM,eAAe,KAAK,GAAG,CAAC,GAAG,UAAU,MAAM;YAEjD,sCAAsC;YACtC,IAAK,IAAI,IAAI,GAAG,IAAI,cAAc,IAAK;gBACrC,MAAM,cAAc,SAAS,CAAC,EAAE,CAAC,KAAK;gBAEtC,0CAA0C;gBAC1C,IAAI,CAAC,MAAM,WAAW,CAAC,QAAQ,CAAC,gBAAgB,MAAM,MAAM,GAAG,gBAAgB;oBAC7E,MAAM,IAAI,CAAC;wBACT,OAAO;+BAAI,MAAM,QAAQ;yBAAC;wBAC1B,KAAK;+BAAI,KAAK,CAAC,YAAY,CAAC,QAAQ;yBAAC;oBACvC;oBAEA,MAAM,WAAW,CAAC,IAAI,CAAC;oBACvB,KAAK,CAAC,YAAY,CAAC,WAAW,CAAC,IAAI,CAAC;gBACtC;YACF;QACF;QAEA,OAAO;IACT,GAAG;QAAC;QAAO;KAAe;IAE1B,iBAAiB;IACjB,CAAA,GAAA,+MAAA,CAAA,WAAQ,AAAD,EAAE,CAAC,OAAO;QACf,IAAI,SAAS,OAAO,IAAI,eAAe,OAAO,EAAE;YAC9C,aAAa;YACb,SAAS,OAAO,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,MAAM;gBACvC,MAAM,WAAW,KAAK,CAAC,EAAE;gBAEzB,kBAAkB;gBAClB,IAAK,IAAI,OAAO,GAAG,OAAO,GAAG,OAAQ;oBACnC,SAAS,QAAQ,CAAC,KAAK,IAAI,SAAS,QAAQ,CAAC,KAAK;oBAElD,wBAAwB;oBACxB,IAAI,KAAK,GAAG,CAAC,SAAS,QAAQ,CAAC,KAAK,IAAI,GAAG;wBACzC,SAAS,QAAQ,CAAC,KAAK,IAAI,CAAC;oBAC9B;gBACF;gBAEA,uBAAuB;gBACvB,KAAK,QAAQ,CAAC,GAAG,CACf,SAAS,QAAQ,CAAC,EAAE,EACpB,SAAS,QAAQ,CAAC,EAAE,EACpB,SAAS,QAAQ,CAAC,EAAE;YAExB;YAEA,qBAAqB;YACrB,eAAe,OAAO,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,MAAM;gBAC7C,MAAM,aAAa,WAAW,CAAC,EAAE;gBACjC,MAAM,YAAY,KAAK,CAAC,MAAM,SAAS,CAAC,CAAA,IACtC,EAAE,QAAQ,CAAC,EAAE,KAAK,WAAW,KAAK,CAAC,EAAE,IACrC,EAAE,QAAQ,CAAC,EAAE,KAAK,WAAW,KAAK,CAAC,EAAE,IACrC,EAAE,QAAQ,CAAC,EAAE,KAAK,WAAW,KAAK,CAAC,EAAE,EACrC;gBAEF,MAAM,UAAU,KAAK,CAAC,MAAM,SAAS,CAAC,CAAA,IACpC,EAAE,QAAQ,CAAC,EAAE,KAAK,WAAW,GAAG,CAAC,EAAE,IACnC,EAAE,QAAQ,CAAC,EAAE,KAAK,WAAW,GAAG,CAAC,EAAE,IACnC,EAAE,QAAQ,CAAC,EAAE,KAAK,WAAW,GAAG,CAAC,EAAE,EACnC;gBAEF,IAAI,aAAa,SAAS;oBACxB,wBAAwB;oBACxB,MAAM,aAAa;wBACjB,IAAI,+IAAA,CAAA,UAAa,CAAC,UAAU,QAAQ,CAAC,EAAE,EAAE,UAAU,QAAQ,CAAC,EAAE,EAAE,UAAU,QAAQ,CAAC,EAAE;wBACrF,IAAI,+IAAA,CAAA,UAAa,CAAC,QAAQ,QAAQ,CAAC,EAAE,EAAE,QAAQ,QAAQ,CAAC,EAAE,EAAE,QAAQ,QAAQ,CAAC,EAAE;qBAChF;oBAEA,KAAa,QAAQ,CAAC,aAAa,CAAC;gBACvC;YACF;YAEA,+BAA+B;YAC/B,SAAS,OAAO,CAAC,QAAQ,CAAC,CAAC,IAAI,QAAQ;YACvC,eAAe,OAAO,CAAC,QAAQ,CAAC,CAAC,IAAI,QAAQ;QAC/C;IACF;IAEA,qBACE;;0BAEE,8OAAC;gBAAM,KAAK;0BACT,MAAM,GAAG,CAAC,CAAC,MAAM,kBAChB,8OAAC;wBAEC,UAAU,IAAI,+IAAA,CAAA,UAAa,IAAI,KAAK,QAAQ;;0CAE5C,8OAAC;gCAAe,MAAM;oCAAC,KAAK,IAAI;oCAAE;oCAAG;iCAAE;;;;;;0CACvC,8OAAC;gCACC,OAAO;gCACP,UAAU;gCACV,mBAAmB;;;;;;;uBAPhB,CAAC,KAAK,EAAE,GAAG;;;;;;;;;;0BActB,8OAAC;gBAAM,KAAK;0BACT,YAAY,GAAG,CAAC,CAAC,YAAY,kBAC5B,8OAAC,wJAAA,CAAA,OAAI;wBAEH,QAAQ;4BACN,IAAI,+IAAA,CAAA,UAAa,IAAI,WAAW,KAAK;4BACrC,IAAI,+IAAA,CAAA,UAAa,IAAI,WAAW,GAAG;yBACpC;wBACD,OAAO;wBACP,WAAW;wBACX,WAAW;wBACX,SAAS;uBARJ,CAAC,WAAW,EAAE,GAAG;;;;;;;;;;;;AAclC;AAOe,SAAS,eAAe,EACrC,QAAQ,SAAS,EACjB,YAAY,iBAAiB,EACT;IACpB,qBACE,8OAAC;QAAI,WAAW,GAAG,UAAU,cAAc,CAAC;kBAC1C,cAAA,8OAAC,mMAAA,CAAA,SAAM;YAAC,KAAK;gBAAC;gBAAG;aAAE;YAAE,QAAQ;gBAAE,UAAU;oBAAC;oBAAG;oBAAG;iBAAG;gBAAE,KAAK;YAAG;;8BAC3D,8OAAC;oBAAa,WAAW;;;;;;8BACzB,8OAAC;oBAAW,UAAU;wBAAC;wBAAI;wBAAI;qBAAG;oBAAE,WAAW;;;;;;8BAC/C,8OAAC;oBAAY,OAAO;;;;;;8BACpB,8OAAC,iKAAA,CAAA,gBAAa;oBACZ,YAAY;oBACZ,WAAW;oBACX,UAAU;oBACV,iBAAiB;;;;;;;;;;;;;;;;;AAK3B","debugId":null}},
    {"offset": {"line": 866, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Users/emmry/Documents/Jethro%20Solutions/jethro-website-1/src/components/background/spiral-particles.tsx"],"sourcesContent":["'use client';\r\n\r\nimport { useRef, useMemo } from 'react';\r\nimport { Canvas, useFrame } from '@react-three/fiber';\r\nimport { OrbitControls, Points, PointMaterial } from '@react-three/drei';\r\nimport * as THREE from 'three';\r\n\r\nfunction SpiralParticles({ color = '#F5A47C', particleCount = 5000 }) {\r\n  const pointsRef = useRef<THREE.Points>(null);\r\n  \r\n  // Generate particles in a spiral formation\r\n  const particles = useMemo(() => {\r\n    const positions = new Float32Array(particleCount * 3);\r\n    const spiralArms = 3;\r\n    const spiralRadius = 5;\r\n    \r\n    for (let i = 0; i < particleCount; i++) {\r\n      const t = i / particleCount;\r\n      const angle = 2 * Math.PI * spiralArms * t;\r\n      const radius = spiralRadius * t;\r\n      \r\n      // Calculate spiral position\r\n      positions[i * 3] = radius * Math.cos(angle);      // x\r\n      positions[i * 3 + 1] = (Math.random() - 0.5) * 2; // y (slight randomness)\r\n      positions[i * 3 + 2] = radius * Math.sin(angle);  // z\r\n    }\r\n    \r\n    return positions;\r\n  }, [particleCount]);\r\n  \r\n  // Animation loop\r\n  useFrame((state, delta) => {\r\n    if (pointsRef.current) {\r\n      const time = state.clock.getElapsedTime();\r\n      \r\n      // Rotate the spiral\r\n      pointsRef.current.rotation.y += delta * 0.1;\r\n      \r\n      // Create a wave-like motion through the spiral\r\n      const positions = pointsRef.current.geometry.attributes.position.array as Float32Array;\r\n      for (let i = 0; i < particleCount; i++) {\r\n        const i3 = i * 3;\r\n        const x = positions[i3];\r\n        const z = positions[i3 + 2];\r\n        \r\n        // Calculate distance from center\r\n        const distance = Math.sqrt(x * x + z * z);\r\n        \r\n        // Apply wave effect based on distance and time\r\n        positions[i3 + 1] = Math.sin(distance - time) * 0.5;\r\n      }\r\n      \r\n      pointsRef.current.geometry.attributes.position.needsUpdate = true;\r\n    }\r\n  });\r\n\r\n  return (\r\n    <Points ref={pointsRef} positions={particles}>\r\n      <PointMaterial\r\n        transparent\r\n        color={color}\r\n        size={0.05}\r\n        sizeAttenuation={true}\r\n        depthWrite={false}\r\n        opacity={0.8}\r\n      />\r\n    </Points>\r\n  );\r\n}\r\n\r\ninterface SpiralParticlesBackgroundProps {\r\n  color?: string;\r\n  className?: string;\r\n}\r\n\r\nexport default function SpiralParticlesBackground({\r\n  color = '#F5A47C',\r\n  className = 'w-full h-screen'\r\n}: SpiralParticlesBackgroundProps) {\r\n  return (\r\n    <div className={`${className} bg-soft-black`}>\r\n      <Canvas dpr={[1, 2]} camera={{ position: [0, 3, 10], fov: 50 }}>\r\n        <ambientLight intensity={0.5} />\r\n        <pointLight position={[10, 10, 10]} intensity={1} />\r\n        <SpiralParticles color={color} />\r\n        <OrbitControls \r\n          enableZoom={false}\r\n          enablePan={false}\r\n          autoRotate\r\n          autoRotateSpeed={0.2}\r\n        />\r\n      </Canvas>\r\n    </div>\r\n  );\r\n} "],"names":[],"mappings":";;;;AAEA;AACA;AAAA;AACA;AAAA;AAAA;AAJA;;;;;AAOA,SAAS,gBAAgB,EAAE,QAAQ,SAAS,EAAE,gBAAgB,IAAI,EAAE;IAClE,MAAM,YAAY,CAAA,GAAA,qMAAA,CAAA,SAAM,AAAD,EAAgB;IAEvC,2CAA2C;IAC3C,MAAM,YAAY,CAAA,GAAA,qMAAA,CAAA,UAAO,AAAD,EAAE;QACxB,MAAM,YAAY,IAAI,aAAa,gBAAgB;QACnD,MAAM,aAAa;QACnB,MAAM,eAAe;QAErB,IAAK,IAAI,IAAI,GAAG,IAAI,eAAe,IAAK;YACtC,MAAM,IAAI,IAAI;YACd,MAAM,QAAQ,IAAI,KAAK,EAAE,GAAG,aAAa;YACzC,MAAM,SAAS,eAAe;YAE9B,4BAA4B;YAC5B,SAAS,CAAC,IAAI,EAAE,GAAG,SAAS,KAAK,GAAG,CAAC,QAAa,IAAI;YACtD,SAAS,CAAC,IAAI,IAAI,EAAE,GAAG,CAAC,KAAK,MAAM,KAAK,GAAG,IAAI,GAAG,wBAAwB;YAC1E,SAAS,CAAC,IAAI,IAAI,EAAE,GAAG,SAAS,KAAK,GAAG,CAAC,QAAS,IAAI;QACxD;QAEA,OAAO;IACT,GAAG;QAAC;KAAc;IAElB,iBAAiB;IACjB,CAAA,GAAA,+MAAA,CAAA,WAAQ,AAAD,EAAE,CAAC,OAAO;QACf,IAAI,UAAU,OAAO,EAAE;YACrB,MAAM,OAAO,MAAM,KAAK,CAAC,cAAc;YAEvC,oBAAoB;YACpB,UAAU,OAAO,CAAC,QAAQ,CAAC,CAAC,IAAI,QAAQ;YAExC,+CAA+C;YAC/C,MAAM,YAAY,UAAU,OAAO,CAAC,QAAQ,CAAC,UAAU,CAAC,QAAQ,CAAC,KAAK;YACtE,IAAK,IAAI,IAAI,GAAG,IAAI,eAAe,IAAK;gBACtC,MAAM,KAAK,IAAI;gBACf,MAAM,IAAI,SAAS,CAAC,GAAG;gBACvB,MAAM,IAAI,SAAS,CAAC,KAAK,EAAE;gBAE3B,iCAAiC;gBACjC,MAAM,WAAW,KAAK,IAAI,CAAC,IAAI,IAAI,IAAI;gBAEvC,+CAA+C;gBAC/C,SAAS,CAAC,KAAK,EAAE,GAAG,KAAK,GAAG,CAAC,WAAW,QAAQ;YAClD;YAEA,UAAU,OAAO,CAAC,QAAQ,CAAC,UAAU,CAAC,QAAQ,CAAC,WAAW,GAAG;QAC/D;IACF;IAEA,qBACE,8OAAC,0JAAA,CAAA,SAAM;QAAC,KAAK;QAAW,WAAW;kBACjC,cAAA,8OAAC,iKAAA,CAAA,gBAAa;YACZ,WAAW;YACX,OAAO;YACP,MAAM;YACN,iBAAiB;YACjB,YAAY;YACZ,SAAS;;;;;;;;;;;AAIjB;AAOe,SAAS,0BAA0B,EAChD,QAAQ,SAAS,EACjB,YAAY,iBAAiB,EACE;IAC/B,qBACE,8OAAC;QAAI,WAAW,GAAG,UAAU,cAAc,CAAC;kBAC1C,cAAA,8OAAC,mMAAA,CAAA,SAAM;YAAC,KAAK;gBAAC;gBAAG;aAAE;YAAE,QAAQ;gBAAE,UAAU;oBAAC;oBAAG;oBAAG;iBAAG;gBAAE,KAAK;YAAG;;8BAC3D,8OAAC;oBAAa,WAAW;;;;;;8BACzB,8OAAC;oBAAW,UAAU;wBAAC;wBAAI;wBAAI;qBAAG;oBAAE,WAAW;;;;;;8BAC/C,8OAAC;oBAAgB,OAAO;;;;;;8BACxB,8OAAC,iKAAA,CAAA,gBAAa;oBACZ,YAAY;oBACZ,WAAW;oBACX,UAAU;oBACV,iBAAiB;;;;;;;;;;;;;;;;;AAK3B","debugId":null}}]
}